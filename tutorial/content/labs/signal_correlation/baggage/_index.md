---
title: "baggage"
draft: false
weight: 2
---


### Why do we need baggage?

{{< figure src="images/baggage.drawio.svg" width=800 caption="propagate baggage" >}}

OpenTelemetry's baggage signal offers as a versatile mechanism for carrying contextual information alongside requests across service boundaries.
It consists of key-value pairs, also known as baggage items.
It provides a standardized approach to attach application-specific details for retrieval later in a transaction's lifecycle.
Much like trace context, baggage builds ontop of OpenTelemetry's context propagation subsystem.
The propagator uses the headers of the communication protocol to inject baggage items into network request (see the [W3C Baggage specification](https://www.w3.org/TR/baggage/)).
Upon receiving a request, a downstream service may extract and leverage the information in their local execution context.

The concept of baggage is fairly general and can be applied in various scenarios.
In this lab, we'll focus on how baggage can be used for indexing observability events.
For example, if one service has access to high-level information (e.g., User IDs, Product IDs), we may want to incorporate these values into the telemetry generated by other services in the transaction.
However, this information may only be available on the initial API request.
Baggage allows the initial service to include this contextual information into request.
Receivers explicitly take out relevant information and append them as additional attributes to its metrics, logs and traces.
This data can be used to connect signals with one another and allows us to uncover correlations by providing additional criteria to query and filter events.
For example, one might target your analysis to spans associated with particular users, filter traces based on the region to isolate issues related to that geographic context, and so on.

### considerations and trade-offs

Nevertheless, baggage comes with its own set of considerations and trade-offs.
<!-- prolific -->
SpanAttributes and baggage let us enrich telemetry with additional context, but they serve distinct purposes.
SpanAttributes provide details about an operation specific to a particular span.
Every span has its own set of attributes, which aren't (at least not automatically) inherited by child spans.
In contrast, baggage transports distributed context which is relevant across multiple services.
As the terminology suggests, you carry your baggage with you.
In other words, baggage is automatically inherited and propagated to subsequent requests without requiring explicit action.
<!-- comes with overhead -->
This can get problematic.
Each item added to baggage must be encoded as a header.
Given baggage tendency to proliferate, we increases the size of every subsequent network request in the transaction.
Therefore, it is recommended that baggage be used sparingly.
<!-- security considerations -->
From a security standpoint, you have to be mindful when adding or extracting information from baggage.
Including sensitive data in baggage should be avoided because headers are visible and can be intercepted during transmission (especially in an unencrypted communication channel).
Since baggage spread across potentially many service, there is always a risk of unintended information leakage.
Developers must exercise caution when extracting and acting on information from baggage.
As there is no built-in integrity checks of baggage items, malicious actors might tamper header contents to exploit vulnerabilities.

 <!-- summary
- a versatile key-value system
  - a general purpose data storage and transmission system, not limited to observability
  - but primarily used to convey values for the OpenTelemetry observability systems

- a form of distributed context 
	- before item put into the context object are only accessible within the current service -> are associated with execution context
	- similar to trace context -> built ontop of OpenTelemetry's context propagation mechanisms
  	- pass valuable contextual information between services separated by a logical boundary
    - use propagator to inject baggage items into network requests as headers
  	- once data is added as baggage, it can be parsed / extracted by downstream services

- a uniform way to make useful information available later in the transaction
  - attach information from your application to retrieve that information later
  - intended for indexing observability events  
    - high-level information (e.g. Account Identification, User IDs, Product IDs, ) in one service
    - want to integrate this information as attributes in the telemetry of downstream services that take part in the same transaction
    - reasons
      - to make it easier to filter when you’re searching in your observability back-end
      - helps to establish a causal relationship between these events
    - problem: later services might not have access to this information (e.g. only available on the initial API request)
    - solution:
      - add contextual data as key value pairs to baggage
      - gets push along with the request (e.g. propagated via HTTP headers as defined in the W3C Baggage specification. )
      - remote services explicitly consumes values from Baggage and appends them as additional attributes to its metrics, logs and traces


- example:
  - a frontend service using project ID as an index could add it as baggage, allows backend services to also index their spans and metrics by project ID
  - wanted to have the CustomerId appear on all your spans
  - logs will automatically be bound to the current trace, if there is one

- not the same as Span attributes
  - when you add something as Baggage, it does not automatically end up on the Attributes of the child system’s spans
  - must explicitly take something out of Baggage and append it as Attributes


- comes at a cost
  - too much baggage because it will add overhead when making HTTP requests. 
	- every item added must be encoded as a header
	- called baggage because it increase the size of every subsequent network request in the transaction
	- therefore it is recommended that baggage be used sparingly

- be mindful
-->

<!-- 



https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/overview.md
tracing, metrics, and baggage are three separate signals.
Signals share a common subsystem – context propagation – but they function independently from each other.
propagators to serialize and deserialize cross-cutting concern values such as Spans (usually only the SpanContext portion) and Baggage



https://doordash.engineering/2021/06/17/leveraging-opentelemetry-for-custom-context-propagation/

https://www.honeycomb.io/blog/ask-miss-o11y-opentelemetry-baggage
- wanted to have the CustomerId appear on all your spans, but it’s only available on the initial API request (as downstream services dont need this context)
- fancy term for contextual information that’s passed between spans.
- passing that context between service boundaries.
- it’s about pushing that context over an HTTP, gRPC, or a message so the other service can use it to add context to its span.
- why the hell does OTel Baggage exist?
  - context values live in the same place, have the same format and follow the same pattern
  - means that all your applications, no matter what the language, will be able to read them, parse them, and use them
- What should I use OTel Baggage for?
  -  nothing sensitive, and nothing that you don’t want third parties to see
  -  y, don’t always trust what you get because there are no built-in integrity checks to ensure it was your Baggage items.
- footgun 
  - Baggage can be prolific … it goes EVERYWHERE. Because it’s in the background and OTel is passing it around without you doing anything, you don’t know it’s happening.
  - if you’re not careful with how you use Baggage Propagation and what you use Baggage for.
- baggage is not a subset of the Span attributes
  - It’s not that unreasonable to assume that when you add something as Baggage, you’re doing it so it ends up on the attributes of the child system’s spans. However, it doesn’t; at least not automatically. You must explicitly take something out of Baggage and append it as attributes.

https://www.alibabacloud.com/help/en/arms/application-monitoring/use-cases/use-opentelemetry-sdk-for-java-to-manually-instrument-applications
 is stored and propagated in HTTP headers

https://grafana.com/blog/2023/12/18/opentelemetry-best-practices-a-users-guide-to-getting-started-with-opentelemetry/#context-propagation
Baggage uses HTTP headers to propagate key-value pairs between spans when that data may not be available to spans further down the stack. Take an example of an origin IP. This data may be available to the first service in the transaction, but unless you specify to propagate it along to the remaining spans, those later services cannot access that data. When you use baggage, you gain the ability to add attributes to future spans based on the values being stored as baggage. 

https://docs.dynatrace.com/docs/extend-dynatrace/opentelemetry/overview/traces#baggage
- an interprocess communication mechanism that allows your services to exchange information across context propagation in a standardized key-value format.

https://rehansaeed.com/deep-dive-into-open-telemetry-for-net/
Similar to attributes, baggage is another way we can add data as name value pairs to a trace. The difference is that baggage travels across process boundaries using a baggage HTTP header as defined in the W3C Baggage specification. It is also added to all spans in a trace.
- hy would you use baggage over attributes
- if you have a global unique identifier for a particular trace like a user ID, order ID or some session ID it might be useful to add it as baggage because it's relevant to all spans in your trace. However, you must be careful not to add too much baggage because it will add overhead when making HTTP requests. 

--- done

https://opentelemetry.io/docs/concepts/signals/baggage/
- is contextual information that’s passed between spans.
- a key-value store that resides alongside span context in a trace, making values available to any span created within that trace.
- uses Context Propagation to pass Baggage around
- each library implementations has propagators that parse and make that Baggage available
- provides a uniform way to store and propagate information across a trace and other signals
- may want to attach information from your application to a span and retrieve that information much later and use it later
  - high-level information (e.g. Account Identification, User IDs, Product IDs, ) that you want to have as attributes on other signals -> make it easier to filter when you’re searching in your Observability back-end
  - multiple services; however, information may only available in one specific service
  - use Baggage to propagate this value to downstream services in your system
- not the same as Span attributes
  - When you add something as Baggage, it does not automatically end up on the Attributes of the child system’s spans. You must explicitly take something out of Baggage and append it as Attributes.

https://opentelemetry.io/docs/specs/otel/overview/#baggage-signal
- mechanism for propagating name/value pairs
- intended for indexing observability events in one service with attributes provided by a prior service in the same transaction
- helps to establish a causal relationship between these events
- primarily intended to convey values for the OpenTelemetry observability systems.
  - values can be consumed from Baggage and used as additional attributes for metrics, or additional context for logs and traces

https://trstringer.com/otel-part5-propagation/
- Monolithic applications are fairly easy to add telemetry to, as all of it stays within the same process. But microservices can add a challenge.

service 1 generated some data called attr1. This is relevant data to service 1, and this might be an attribute that we want to add to spans in service 2 and/or service 3. But those services might not have access to this particular data. The way we can solve this with OpenTelemetry is through the use of baggage. Baggage essentially allows us to pass data through requests for other services to use.
In our consuming service (in the diagram, this could either be service 2 or service 3) we can now parse the baggage from the request:
This code gets the request baggage and adds it as a span attribute to the current span.

https://opentelemetry.io/docs/specs/otel/baggage/api/
- used to annotate telemetry, adding context and information to metrics, traces, and logs
- a set of name/value pairs describing user-defined properties
- Baggage API consists of:
  - the Baggage
  - functions to interact with the Baggage in a Context
  - ...

https://www.w3.org/TR/baggage/
- propagating a set of application-defined properties associated with a distributed request
- . Baggage can be used regardless of whether Distributed Tracing is used
-  baggage header is used to propagate user-supplied key-value pairs through a distributed request
-  A system receiving a baggage request header SHOULD send it to outgoing requests. A system MAY mutate the value of this header before passing it on.


-->